<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>01-快速排序算法</title>
    <link href="/2025/06/08/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2025/06/08/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、快速排序算法介绍"><a href="#一、快速排序算法介绍" class="headerlink" title="一、快速排序算法介绍"></a>一、快速排序算法介绍</h1><p>快速排序也是一种期望时间复杂度为O(nlogn)的算法，期望空间复杂度是O(logn)，快速排序是不稳定的排序，这里考虑的是递归调用导致的空间复杂度，最坏时间复杂度和空间复杂度分别是O(n^2)和O(n)。<br>为什么最好的空间复杂度是O(logn)，因为每次假设选择枢纽元恰好是整个数组的中点元素，那么递归调用会形成一棵二叉树结构，递归的空间复杂度就是二叉树的深度，也就是log级别。<br>快速排序的实现需要借助一个辅助函数partition<br>所谓的partition就是分区的意思，在快速排序中借助partition将序列中的元素进行划分，首先在序列中随机选取一个枢纽元pivot，然后partition操作会将序列中所有小于pivot的元素全部移动到序列的左半部分，等于pivot的元素全部移动到中间部分，大于pivot的元素全部移动到右半部分。</p><h1 id="二、快速排序实现"><a href="#二、快速排序实现" class="headerlink" title="二、快速排序实现"></a>二、快速排序实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 西城风雨楼</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> create at 2024/7/21 16:16</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;;<br>        sort(arr);<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        sortHelper(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortHelper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left &gt;= right) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> randomPivot(left, right);<br>        <span class="hljs-type">int</span>[] equals = partition(arr, left, right, p);<br>        sortHelper(arr, left, equals[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>);<br>        sortHelper(arr, equals[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>, right);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = tmp;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">randomPivot</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">return</span> left + (<span class="hljs-type">int</span>) (Math.random() * (right - left + <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] partition(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> p) &#123;<br>        swap(arr, p, right);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">less</span> <span class="hljs-operator">=</span> left - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">more</span> <span class="hljs-operator">=</span> right;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> left;<br><br>        <span class="hljs-keyword">while</span> (cur &lt; more) &#123;<br>            <span class="hljs-keyword">if</span> (arr[cur] &lt; arr[right]) &#123;<br>                <span class="hljs-comment">// 这里cur需要++原因是，cur和less之间要么没有元素</span><br>                <span class="hljs-comment">// 要么就是全部等于pivot，所以交换后，cur位置的值要</span><br>                <span class="hljs-comment">// 么是自己，要么是等于pivot的数</span><br>                swap(arr, ++less, cur++);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[cur] &gt; arr[right]) &#123;<br>                swap(arr, --more, cur);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 将枢纽元放入正确的位置</span><br>        <span class="hljs-comment">// 交换过后more对应的就是等于pivot的最右侧</span><br>        <span class="hljs-comment">// less+1就是等于pivot的最左侧</span><br>        swap(arr, more, right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;less + <span class="hljs-number">1</span>, more&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、补充说明"><a href="#三、补充说明" class="headerlink" title="三、补充说明"></a>三、补充说明</h1><p>快速排序的时间复杂度好坏取决于枢纽元选取的随机性，如果选取的枢纽元刚好是整个数组的中位数，那么最后划分出来的子数组也会特别均匀，时间复杂度就刚好是O(nlogn)，此时的Master公式为：<br>T(N) &#x3D; 2 * T(N&#x2F;2) + O(N)，其中O(N)是partiton操作。<br>快速排序在枢纽元选取比较随机的情况下，平均时间复杂度为O(nlogn)，随机函数本身可能带来时间开销，还有一种在数据结构与算法C语言描述书中推荐的一种方法：</p><ol><li>将枢纽元选择为第一个元素，最后一个元素，中间位置的元素，这三个元素的中间值，然后放到数组的最后面</li><li>当数组元素不足3个时(或者不足某个阈值时)，可以使用插入排序<br>采用这种方法，partition也需要做相应的改造，其他部分可以不用变，这里给出改造后的paritition和枢纽元选择代码：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 西城风雨楼</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> create at 2024/7/21 16:16</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;;<br>        sort(arr);<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        sortHelper(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortHelper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left &gt;= right) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        threeMedianPivot(arr, left, right);<br>        <span class="hljs-type">int</span>[] equals = partition(arr, left, right);<br>        sortHelper(arr, left, equals[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>);<br>        sortHelper(arr, equals[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>, right);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = tmp;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在left，mid以及right这三个元素中选择中间值作为枢纽元</span><br><span class="hljs-comment">     * 在选择枢纽元的同时，让left最终为这三个值中的最小者，mid为最大者</span><br><span class="hljs-comment">     * right为枢纽元本身</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> left</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> right</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">threeMedianPivot</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (arr[left] &gt; arr[mid]) &#123;<br>            <span class="hljs-comment">// left成为left和mid二者的最小值</span><br>            swap(arr, left, mid);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (arr[left] &gt; arr[right]) &#123;<br>            <span class="hljs-comment">// left成为三者中的最小值</span><br>            swap(arr, left, right);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (arr[mid] &lt; arr[right]) &#123;<br>            <span class="hljs-comment">// 让right成为枢纽元</span><br>            swap(arr, mid, right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] partition(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right) &#123;<br>        <span class="hljs-comment">// left就可以作为left的边界了，因为在设置枢纽元的时候，left位置已经是小于</span><br>        <span class="hljs-comment">// 等于枢纽元的数字了</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">less</span> <span class="hljs-operator">=</span> left;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">more</span> <span class="hljs-operator">=</span> right;<br>        <span class="hljs-comment">// cur要从less+1开始</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (cur &lt; more) &#123;<br>            <span class="hljs-keyword">if</span> (arr[cur] &lt; arr[right]) &#123;<br>                <span class="hljs-comment">// 这里cur需要++原因是，cur和less之间要么没有元素</span><br>                <span class="hljs-comment">// 要么就是全部等于pivot，所以交换后，cur位置的值要</span><br>                <span class="hljs-comment">// 么是自己，要么是等于pivot的数</span><br>                swap(arr, ++less, cur++);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[cur] &gt; arr[right]) &#123;<br>                swap(arr, --more, cur);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 将枢纽元放入正确的位置</span><br>        <span class="hljs-comment">// 交换过后more对应的就是等于pivot的最右侧</span><br>        <span class="hljs-comment">// less+1就是等于pivot的最左侧</span><br>        swap(arr, more, right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;less + <span class="hljs-number">1</span>, more&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
